// Generated by CoffeeScript 1.8.0
(function() {
  describe('TaskCruncher Spec: ', function() {
    var type;
    it('Use Jasmine with Version 2.xx', function() {
      expect(jasmine.version).toMatch(/^2\./);
    });
    type = (function() {
      var classToType, prop, _fn, _i, _len, _ref;
      classToType = {};
      _ref = 'Boolean Number String Function Array Date RegExp Object'.split(' ');
      _fn = function(prop) {
        return classToType["[object " + prop + "]"] = prop.toLowerCase();
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        _fn(prop);
      }
      return function(obj) {
        if (obj === void 0 || obj === null) {
          return String(obj);
        }
        return classToType[Object.prototype.toString.call(obj)];
      };
    })();
    describe('Declaration: ', function() {
      it('declares a type CrunchTask on the global scope', function() {
        expect(CrunchTask).toBeDefined();
      });
    });
    describe('Instantiation: ', function() {
      it('create instances of CrunchTask class by a function call', function() {
        var result;
        result = CrunchTask(function() {});
        expect(result instanceof CrunchTask).toEqual(true);
      });
      it('.. or by a `new` keyword instantiation', function() {
        var result;
        result = new CrunchTask(function() {});
        expect(result instanceof CrunchTask).toEqual(true);
      });
      it('required is the only argument, a task description function', function() {
        expect(function() {
          return new CrunchTask(function() {});
        }).not.toThrow();
      });
      it('throws Error if required parameter is not passed', function() {
        expect(function() {
          return CrunchTask();
        }).toThrow();
        expect(function() {
          return CrunchTask(1, 2, 3);
        }).toThrow();
      });
    });
    describe('API. CrunchTask instance..', function() {
      var task;
      task = null;
      beforeEach(function() {
        return task = new CrunchTask(function(init, body, fin) {});
      });
      it('has an `id` property, a unique task identifier, of type Number', function() {
        expect(task.id).toBeDefined();
        expect(type(task.id)).toEqual('number');
      });
      it('has a `timestamp` property, a timestamp when the task was created, of type Number', function() {
        expect(task.timestamp).toBeDefined();
        expect(type(task.timestamp)).toEqual('number');
        expect(Math.abs(new Date() - task.timestamp) < 1000).toBe(true);
      });
      it('declares `run()` method', function() {
        expect(task.run).toBeDefined();
        expect(type(task.run)).toEqual('function');
      });
      it('declares `then()` method', function() {
        expect(task.then).toBeDefined();
        expect(type(task.then)).toEqual('function');
      });
      it('declares `onRun()` method', function() {
        expect(task.onRun).toBeDefined();
        expect(type(task.onRun)).toEqual('function');
      });
      it('declares `onIdle()` method', function() {
        expect(task.onIdle).toBeDefined();
        expect(type(task.onIdle)).toEqual('function');
      });
      it('declares `done()` method', function() {
        expect(task.done).toBeDefined();
        expect(type(task.done)).toEqual('function');
      });
      it('declares `fail()` method', function() {
        expect(task.fail).toBeDefined();
        expect(type(task.fail)).toEqual('function');
      });
      it('declares `always()` method', function() {
        expect(task.always).toBeDefined();
        expect(type(task.always)).toEqual('function');
      });
      it('declares `progress()` method', function() {
        expect(task.progress).toBeDefined();
        expect(type(task.progress)).toEqual('function');
      });
      it('declares `abort()` method', function() {
        expect(task.abort).toBeDefined();
        expect(type(task.abort)).toEqual('function');
      });
      it('declares `pause()` method', function() {
        expect(task.pause).toBeDefined();
        expect(type(task.pause)).toEqual('function');
      });
      it('declares `resume()` method', function() {
        expect(task.resume).toBeDefined();
        expect(type(task.resume)).toEqual('function');
      });
      it('declares `isIdle():{Boolean}` method', function() {
        expect(task.isIdle).toBeDefined();
        expect(type(task.isIdle)).toEqual('function');
      });
      it('returns a promise object when `run(args..):{Promise}` is called', function() {
        var result;
        result = task.run();
        expect(result).toBeDefined();
        expect(result instanceof Promise).toEqual(true);
      });
      it('rejects the run when no `body` is supplied', function(done) {
        var foo;
        foo = {
          bar: function() {}
        };
        spyOn(foo, 'bar').and.callThrough();
        task = new CrunchTask(function(init, body, fin) {});
        task.fail(foo.bar);
        expect(foo.bar.calls.any()).toEqual(false);
        task.run();
        window.setTimeout(function() {
          expect(foo.bar.calls.any()).toEqual(true);
          expect(foo.bar.calls.argsFor(0)[0] instanceof Error).toEqual(true);
          return done();
        }, 1000);
      });
      return;
      describe('some instance methods can be chained', function() {
        task = null;
        beforeEach(function() {
          return task = new CrunchTask(function(init, body, fin) {});
        });
        it('all task\'s methods can be invoked on the result of `onRun():{CrunchTask}` method', function() {
          expect(task.onRun(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `onIdle():{CrunchTask}` method', function() {
          expect(task.onIdle(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `done():{CrunchTask}` method', function() {
          expect(task.done(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `fail():{CrunchTask}` method', function() {
          expect(task.fail(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `always():{CrunchTask}` method', function() {
          expect(task.always(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `progress():{CrunchTask}` method', function() {
          expect(task.progress(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `abort():{CrunchTask}` method', function() {
          expect(task.abort(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `pause():{CrunchTask}` method', function() {
          expect(task.pause(function() {}) instanceof CrunchTask).toBe(true);
        });
        it('all task\'s methods can be invoked on the result of `resume():{CrunchTask}` method', function() {
          expect(task.resume(function() {}) instanceof CrunchTask).toBe(true);
        });
      });
      describe('the `promise` object obtained by `run()` has three extra methods:', function() {
        var runResult;
        runResult = null;
        beforeEach(function() {
          return runResult = task.run();
        });
        afterEach(function() {
          return runResult = null;
        });
        it('declares `abort()` method', function() {
          expect(runResult.abort).toBeDefined();
          expect(type(runResult.abort)).toEqual('function');
        });
        it('declares `pause()` method', function() {
          expect(runResult.pause).toBeDefined();
          expect(type(runResult.pause)).toEqual('function');
        });
        it('declares `resume()` method', function() {
          expect(runResult.resume).toBeDefined();
          expect(type(runResult.resume)).toEqual('function');
        });
      });
      return describe('Convenience static method `for`', function() {
        it('declares static deprecated `for()` method', function() {
          expect(CrunchTask["for"]).toBeDefined();
          expect(type(CrunchTask["for"])).toEqual('function');
        });
        it('declares static `range()` method (supercedes `for()`)', function() {
          expect(CrunchTask.range).toBeDefined();
          expect(type(CrunchTask.range)).toEqual('function');
        });
        it('declares static `rangeCheck()` method', function() {
          expect(CrunchTask.rangeCheck).toBeDefined();
          expect(type(CrunchTask.rangeCheck)).toEqual('function');
        });
        it('declares static `rangeNextAndCheck` method', function() {
          expect(CrunchTask.rangeNextAndCheck).toBeDefined();
          expect(type(CrunchTask.rangeNextAndCheck)).toEqual('function');
        });
        describe('`rangeCheck()` method parses the arguments into async-for-loop-ready structure', function() {
          it('no arguments produces empty ranges array and is OK', function() {
            expect(CrunchTask.rangeCheck()).toEqual([]);
          });
          it('only numerics, bools, and arrays are considered as args', function() {
            var undef;;
            expect(CrunchTask.rangeCheck('123', undef, /123/)).toEqual([]);
          });
          it('a valid range is represented by the array of 3 numbers and an `inclusive` flag', function() {
            expect(CrunchTask.rangeCheck(0, 9, .5, true)).toEqual([
              {
                from: 0,
                current: 0,
                to: 9,
                step: .5,
                inclusive: true
              }
            ]);
          });
          it('the first number represents a range\'s `from` value', function() {
            var from;
            from = 5;
            expect(CrunchTask.rangeCheck(from, 9, .5, true)[0].from).toEqual(from);
            from = -5;
            expect(CrunchTask.rangeCheck(from, 9, .5, true)[0].from).toEqual(from);
          });
          it('the second number represents a range\'s `to` value', function() {
            var to;
            to = 5;
            expect(CrunchTask.rangeCheck(5, to, .5, true)[0].to).toEqual(to);
            to = -5;
            expect(CrunchTask.rangeCheck(5, to, .5, true)[0].to).toEqual(to);
          });
          it('the third number represents a `step` value ', function() {
            var step;
            step = 5;
            expect(CrunchTask.rangeCheck(0, 9, step, true)[0].step).toEqual(step);
            step = -5;
            expect(CrunchTask.rangeCheck(0, 9, step, true)[0].step).toEqual(step);
            step = .5;
            expect(CrunchTask.rangeCheck(0, 9, step, true)[0].step).toEqual(step);
          });
          it('if the `step` is omitted, it defaults to +1 if (`from` <= `to`), and -1 otherwise', function() {
            var from, to;
            from = 0;
            to = 10;
            expect(CrunchTask.rangeCheck(from, to)[0].step).toEqual(+1);
            from = 10;
            to = 10;
            expect(CrunchTask.rangeCheck(from, to)[0].step).toEqual(+1);
            from = 10;
            to = 0;
            expect(CrunchTask.rangeCheck(from, to)[0].step).toEqual(-1);
            from = 0;
            to = 10;
            expect(CrunchTask.rangeCheck(from, to, false)[0].step).toEqual(+1);
            from = 10;
            to = 10;
            expect(CrunchTask.rangeCheck(from, to, false)[0].step).toEqual(+1);
            from = 10;
            to = 0;
            expect(CrunchTask.rangeCheck(from, to, false)[0].step).toEqual(-1);
          });
          it('if the `inclusive` is omitted, it defaults to `false`', function() {
            expect(CrunchTask.rangeCheck(0, 9)[0].inclusive).toEqual(false);
            expect(CrunchTask.rangeCheck(0, 9, .5)[0].inclusive).toEqual(false);
          });
          it('so the minimum of two numbers define a range `0,10` mean `from 0 to 10`', function() {
            expect(function() {
              return CrunchTask.rangeCheck(0, 9);
            }).not.toThrow();
          });
          it('less than 2 numeric arguments do not represent a valid range and an error is thrown', function() {
            expect(function() {
              return CrunchTask.rangeCheck(0);
            }).toThrow();
            expect(function() {
              return CrunchTask.rangeCheck(0, true);
            }).toThrow();
          });
          it('two or more ranges can be defined in a flat list if `inclusive` flag is supplied for each', function() {
            expect(function() {
              CrunchTask.rangeCheck(0, 9, 1, true, 9, 0, -1, true);
              return CrunchTask.rangeCheck(0, 9, 1, true, 9, 0, -1, true, 5, 1, false);
            }).not.toThrow();
            expect(CrunchTask.rangeCheck(0, 9, 1, true, 9, 0, -1, true)).toEqual([
              {
                from: 0,
                current: 0,
                to: 9,
                step: 1,
                inclusive: true
              }, {
                from: 9,
                current: 9,
                to: 0,
                step: -1,
                inclusive: true
              }
            ]);
            expect(CrunchTask.rangeCheck(0, 9, 1, true, 9, 0, -1, true, 5, 1, false)).toEqual([
              {
                from: 0,
                current: 0,
                to: 9,
                step: 1,
                inclusive: true
              }, {
                from: 9,
                current: 9,
                to: 0,
                step: -1,
                inclusive: true
              }, {
                from: 5,
                current: 5,
                to: 1,
                step: -1,
                inclusive: false
              }
            ]);
          });
          it('this way, the bools serve as comma. Thus the last bool can be omitted if need be', function() {
            expect(function() {
              return CrunchTask.rangeCheck(0, 9, 1, true, 9, 0, -1, true, 5, 1);
            }).not.toThrow();
            expect(CrunchTask.rangeCheck(0, 9, 1, true, 9, 0, -1, true, 5, 1)).toEqual([
              {
                from: 0,
                current: 0,
                to: 9,
                step: 1,
                inclusive: true
              }, {
                from: 9,
                current: 9,
                to: 0,
                step: -1,
                inclusive: true
              }, {
                from: 5,
                current: 5,
                to: 1,
                step: -1,
                inclusive: false
              }
            ]);
          });
          it('however, this cannot be done safely for mid-list bools, they are obligatory', function() {
            expect(function() {
              return CrunchTask.rangeCheck(0, 9, 1, 9, 0, -1);
            }).toThrow();
            expect(function() {
              return CrunchTask.rangeCheck(0, 9, 1, 9, 0, -1, 5, 1);
            }).toThrow();
            expect(function() {
              return CrunchTask.rangeCheck(0, 9, 1, 9);
            }).toThrow();
          });
          it('it can be advised to use arrays to group individual ranges', function() {
            expect(function() {
              return CrunchTask.rangeCheck([0, 9], [1, 9]);
            }).not.toThrow();
          });
          it('the same rules apply to these individual array as for the flat list args described above. Nested arrays are ignored, though', function() {
            expect(function() {
              return CrunchTask.rangeCheck([0, 9, [1, 9]]);
            }).not.toThrow();
            expect(CrunchTask.rangeCheck([0, 9, [1, 9]])).toEqual([
              {
                from: 0,
                current: 0,
                to: 9,
                step: 1,
                inclusive: false
              }
            ]);
          });
          it('arrays can be mixed with the valid ranges chains with expected valid results', function() {
            var result;
            result = null;
            expect(function() {
              return result = CrunchTask.rangeCheck([0, 9], 9, 0, -.5, false, 9, 0, -.5, [1, 9, true], 9, 0, -.5, false, [0, 5]);
            }).not.toThrow();
            expect(result).toEqual([
              {
                from: 0,
                current: 0,
                to: 9,
                step: 1,
                inclusive: false
              }, {
                from: 9,
                current: 9,
                to: 0,
                step: -0.5,
                inclusive: false
              }, {
                from: 9,
                current: 9,
                to: 0,
                step: -0.5,
                inclusive: false
              }, {
                from: 1,
                current: 1,
                to: 9,
                step: 1,
                inclusive: true
              }, {
                from: 9,
                current: 9,
                to: 0,
                step: -0.5,
                inclusive: false
              }, {
                from: 0,
                current: 0,
                to: 5,
                step: 1,
                inclusive: false
              }
            ]);
          });
          it('ranges can be used to imitate binary permutation', function() {
            expect(CrunchTask.rangeCheck(0, 1, true, 0, 1, true, 0, 1, true)).toEqual([
              {
                from: 0,
                current: 0,
                to: 1,
                step: 1,
                inclusive: true
              }, {
                from: 0,
                current: 0,
                to: 1,
                step: 1,
                inclusive: true
              }, {
                from: 0,
                current: 0,
                to: 1,
                step: 1,
                inclusive: true
              }
            ]);
          });
        });
        describe('`rangeNextAndCheck()` method tries to advance the current position of the ranges structure', function() {
          var range;
          range = null;
          beforeEach(function() {
            return range = CrunchTask.rangeCheck(0, 1, true);
          });
          it('advances the elements of the range structure and responds whether it has not reached the end yet (hasn\'t looped over)', function() {
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
          });
          it('inclusive range of [0..1] reaches the end in two calls.', function() {
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(false);
          });
          it('so does the inclusive range of [1..0]', function() {
            range = CrunchTask.rangeCheck(1, 0, true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(false);
          });
          it('non-inclusive range of [0..1) reaches end with each call', function() {
            range = CrunchTask.rangeCheck(0, 1);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(false);
          });
          it('a non-inclusive range of [0..1) with step .5 reaches end with two calls', function() {
            range = CrunchTask.rangeCheck(0, 1, .5);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(false);
          });
          it('so does the reverse range of [1..0) with step -.5', function() {
            range = CrunchTask.rangeCheck(1, 0, -.5);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(false);
          });
          it('it takes four iterations to iterate fully two binary ranges [0..1]&[0..1]', function() {
            range = CrunchTask.rangeCheck(0, 1, true, 0, 1, true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(true);
            expect(CrunchTask.rangeNextAndCheck(range)).toBe(false);
          });
        });
        describe('the `for()` method', function() {
          var foo;
          foo = {};
          beforeEach(function() {
            return foo.bar = (function() {});
          });
          it('once called, the `for()` method creates a CrunchTask instance', function() {
            var forLoop;
            forLoop = CrunchTask["for"](function() {});
            expect(forLoop instanceof CrunchTask).toBe(true);
          });
          it('the `for()` method accepts loop control numbers and a worker function (or two functions: body and tail) or a task', function(done) {
            var forLoop;
            spyOn(foo, 'bar').and.callThrough();
            forLoop = CrunchTask["for"](0, 2, foo.bar);
            expect(foo.bar).not.toHaveBeenCalled();
            forLoop.run();
            setTimeout(function() {
              expect(foo.bar).toHaveBeenCalled();
              expect(foo.bar.calls.count()).toEqual(2);
              expect(foo.bar.calls.argsFor(0)).toEqual([0]);
              return done();
            }, 10);
          });
          it('the loop control values, supplied for the `for()` method, are overrun by the ones supplied for the `run()` method', function(done) {
            var forLoop;
            spyOn(foo, 'bar').and.callThrough();
            forLoop = CrunchTask["for"](0, 2, foo.bar);
            expect(foo.bar).not.toHaveBeenCalled();
            forLoop.run(0, 5);
            setTimeout(function() {
              expect(foo.bar).toHaveBeenCalled();
              expect(foo.bar.calls.count()).toEqual(5);
              expect(foo.bar.calls.argsFor(0)).toEqual([0]);
              expect(foo.bar.calls.argsFor(1)).toEqual([1]);
              expect(foo.bar.calls.argsFor(2)).toEqual([2]);
              expect(foo.bar.calls.argsFor(3)).toEqual([3]);
              expect(foo.bar.calls.argsFor(4)).toEqual([4]);
              return done();
            }, 10);
          });
          it('loop-control values may be supplied in groups, their behavior is explained in the `rangeCheck()` section above', function(done) {
            var forLoop;
            spyOn(foo, 'bar').and.callThrough();
            forLoop = CrunchTask["for"]([0, 2], [0, 2], foo.bar);
            expect(foo.bar).not.toHaveBeenCalled();
            forLoop.done(function() {
              expect(foo.bar).toHaveBeenCalled();
              expect(foo.bar.calls.count()).toEqual(4);
              expect(foo.bar.calls.argsFor(0)).toEqual([0, 0]);
              expect(foo.bar.calls.argsFor(1)).toEqual([1, 0]);
              expect(foo.bar.calls.argsFor(2)).toEqual([0, 1]);
              expect(foo.bar.calls.argsFor(3)).toEqual([1, 1]);
              return done();
            });
            forLoop.run();
          });
          it('loop-control values in the group may initiate a countdown loop..', function(done) {
            var forLoop;
            spyOn(foo, 'bar').and.callThrough();
            forLoop = CrunchTask["for"]([1, -1], [1, -1], foo.bar);
            expect(foo.bar).not.toHaveBeenCalled();
            forLoop.done(function() {
              expect(foo.bar).toHaveBeenCalled();
              expect(foo.bar.calls.count()).toEqual(4);
              expect(foo.bar.calls.argsFor(0)).toEqual([1, 1]);
              expect(foo.bar.calls.argsFor(1)).toEqual([0, 1]);
              expect(foo.bar.calls.argsFor(2)).toEqual([1, 0]);
              expect(foo.bar.calls.argsFor(3)).toEqual([0, 0]);
              return done();
            });
            forLoop.run();
          });
          it('if no function is supplied, the loop resolves automatically when started', function(done) {
            var forLoop;
            spyOn(foo, 'bar');
            forLoop = CrunchTask["for"]();
            forLoop.done(foo.bar);
            expect(foo.bar.calls.any()).toEqual(false);
            forLoop.run();
            setTimeout(function() {
              expect(foo.bar.calls.any()).toEqual(true);
              return done();
            }, 10);
          });
        });
      });
    });
    describe('Usage Patterns: ', function() {
      var task;
      task = null;
      beforeEach(function() {
        return task = new CrunchTask(function(init, body, fin) {});
      });
      it('uses a simple construction function', function() {
        var result;
        result = new CrunchTask(function(init, body, fin) {
          return expect(true).toEqual(true);
        });
        return result.run();
      });
      it('..which expects the tree arguments (`init, body, fin`) to be functions', function(done) {
        var result;
        result = new CrunchTask(function(init, body, fin) {
          expect(init).toBeDefined();
          expect(type(init)).toEqual('function');
          expect(body).toBeDefined();
          expect(type(body)).toEqual('function');
          expect(fin).toBeDefined();
          expect(type(fin)).toEqual('function');
          done();
        });
        return result.run();
      });
      it('uses `init` function to inject runtime values into execution scope. Sample 1 - Empty', function(done) {
        var result;
        result = new CrunchTask(function(init, body, fin) {
          init(function(arg1) {
            expect(arg1).not.toBeDefined();
            return done();
          });
        });
        return result.run();
      });
      it('uses `init` function to inject runtime values into execution scope. Sample 2 - One arg', function(done) {
        var result;
        result = new CrunchTask(function(init, body, fin) {
          init(function(arg1) {
            expect(arg1).toBeDefined();
            expect(arg1).toEqual(123);
            return done();
          });
          body(function() {
            throw new Error('stop');
          });
        });
        return result.run(123);
      });
      it('uses `init` function to inject runtime values into execution scope. Sample 3 - Few args', function(done) {
        var result;
        result = new CrunchTask(function(init, body, fin) {
          init(function(arg1, arg2) {
            expect(arg1).toBeDefined();
            expect(arg1).toEqual(123);
            expect(arg2).toBeDefined();
            expect(arg2).toEqual('456');
            return done();
          });
          body(function() {
            throw new Error('stop');
          });
        });
        return result.run(123, '456');
      });
      it('allows `body` function to operate on values injected with `init`', function(done) {
        task = new CrunchTask(function(init, body, fin) {
          var result;
          result = null;
          init(function(arg1) {
            return result = arg1;
          });
          body(function() {
            expect(result).toBeDefined();
            expect(result).toEqual(123);
            done();
            throw new Error('stop');
          });
        });
        return task.run(123);
      });
      it('uses `body` to control flow with two c/backs (`resolve, reject`). Sample - resolve', function(done) {
        task = new CrunchTask(function(init, body, fin) {
          body(function(resolve, reject, notify) {
            return resolve(123);
          });
        });
        return task.run().then((function(arg) {
          expect(arg).toEqual([123]);
          done();
        }), function() {});
      });
      it('uses `body` to control flow with two c/backs (`resolve, reject`). Sample - reject', function(done) {
        task = new CrunchTask(function(init, body, fin) {
          body(function(resolve, reject, notify) {
            return reject(123);
          });
        });
        return task.run().then(function() {}, (function(arg) {
          expect(arg).toEqual([123]);
          done();
        }));
      });
      it('executes only once, when the second parameter to the `body` callback is `false`', function(done) {
        var foo;
        foo = {
          bar: function(resolve, reject) {}
        };
        setTimeout(done, 5000);
        spyOn(foo, 'bar').and.callThrough();
        task = new CrunchTask(function(init, body, fin) {
          body(foo.bar, false);
          fin(done);
        });
        task.always(function() {
          expect(foo.bar.calls.any()).toEqual(true);
          expect(foo.bar.calls.count()).toEqual(1);
          return done();
        });
        expect(foo.bar.calls.any()).toEqual(false);
        return task.run();
      });
      it('packs execution of the `body` c/back under the amount of passed ms, if possible', function(done) {
        var batchExecTimeLimitMilliseconds, foo;
        foo = {
          bar: (function() {})
        };
        spyOn(foo, 'bar').and.callThrough();
        batchExecTimeLimitMilliseconds = 100;
        task = new CrunchTask(function(init, body, fin) {
          var count, started;
          count = 250;
          started = 0;
          init(function(_started) {
            return started = _started;
          });
          body(function(resolve, reject, notify, diag) {
            foo.bar(diag.batchStarted - 0, diag.batchIndex, diag.batchElapsed);
            if (!(--count)) {
              return resolve();
            }
          }, batchExecTimeLimitMilliseconds);
        });
        task.always(function() {
          var i, _i, _j, _ref, _ref1;
          expect(foo.bar.calls.count()).toEqual(250);
          for (i = _i = 0, _ref = foo.bar.calls.count(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            expect(foo.bar.calls.argsFor(i)[2]).toBeLessThan(batchExecTimeLimitMilliseconds);
          }
          for (i = _j = 1, _ref1 = foo.bar.calls.count(); 1 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
            if (foo.bar.calls.argsFor(i)[1] > foo.bar.calls.argsFor(i - 1)[1]) {
              expect(foo.bar.calls.argsFor(i)[0]).toEqual(foo.bar.calls.argsFor(i - 1)[0]);
            }
          }
          return done();
        });
        return task.run(new Date() - 0);
      });
      it('spaces execution of the `body` c/back for the amount passed in the third parameter', function(done) {
        var executionTimeout, foo, started;
        foo = {
          bar: (function() {})
        };
        spyOn(foo, 'bar').and.callThrough();
        executionTimeout = 500;
        task = new CrunchTask(function(init, body, fin) {
          var count, started;
          count = 2;
          started = 0;
          init(function(_started) {
            return started = _started;
          });
          body(function(resolve, reject, notify, diag) {
            foo.bar(diag.batchStarted);
            if (!(count--)) {
              return resolve();
            }
          }, 0, executionTimeout);
        });
        started = new Date() - 0;
        task.done(function() {
          expect(Math.abs(started - foo.bar.calls.argsFor(0)[0])).toBeGreaterThan(executionTimeout - 1);
          expect(Math.abs(foo.bar.calls.argsFor(0)[0] - foo.bar.calls.argsFor(1)[0])).toBeGreaterThan(executionTimeout - 1);
          return done();
        });
        return task.run();
      });
      it('wraps all arguments into an array for Promise endpoints, unwraps for own handlers. Sample - resolve', function(done) {
        task = new CrunchTask(function(init, body, fin) {
          body(function(resolve, reject, notify) {
            return resolve(123);
          });
        });
        task.done(function(arg) {
          expect(arg).toEqual(123);
          done();
        });
        return task.run();
      });
      it('wraps all arguments into an array for Promise endpoints, unwraps for own handlers. Sample - reject', function(done) {
        task = new CrunchTask(function(init, body, fin) {
          body(function(resolve, reject, notify) {
            return reject(123);
          });
        });
        task.fail(function(arg) {
          expect(arg).toEqual(123);
          done();
        });
        return task.run();
      });
      it('allows to subscribe to `onRun` handler', function() {
        spyOn(task, 'onRun').and.callThrough();
        task.onRun(function(arg1, arg2, arg3) {});
        return expect(task.onRun).toHaveBeenCalled();
      });
      it('triggers `onRun` handlers when `run()` is called', function(done) {
        task.onRun(function(arg1, arg2, arg3) {
          return done();
        });
        return task.run();
      });
      it('allows to subscribe to completion `done` handler', function() {
        spyOn(task, 'done').and.callThrough();
        task.done(function(arg1, arg2, arg3) {});
        return expect(task.done).toHaveBeenCalled();
      });
      it('always triggers `always` handlers when completion is reached', function(done) {
        task = new CrunchTask((function() {}));
        task.always(function(arg1, arg2, arg3) {
          expect(arg1).toBeDefined();
          return done();
        });
        task.run();
      });
      it('can be chained with the `then()` method creating a new task', function() {
        var result1, result2, result3;
        result1 = new CrunchTask(function(init, body, fin) {});
        result2 = new CrunchTask(function(init, body, fin) {});
        result3 = result1.then(result2);
        expect(result3).not.toEqual(result1);
        expect(result3).not.toEqual(result2);
        expect(result3 instanceof CrunchTask).toEqual(true);
      });
    });
    describe('close-to-real usage examples', function() {
      var originalTimeout;
      originalTimeout = null;
      originalTimeout = jasmine.getEnv().defaultTimeoutInterval || jasmine.DEFAULT_TIMEOUT_INTERVAL;
      beforeEach(function(done) {
        originalTimeout = jasmine.getEnv().defaultTimeoutInterval || jasmine.DEFAULT_TIMEOUT_INTERVAL;
        jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;
        done();
      });
      afterEach(function() {
        jasmine.getEnv().defaultTimeoutInterval = originalTimeout;
        jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;
      });
      it('uses `body`/`notify` c/back to notify listeners of the progress of the task', (function(done) {
        var foo, runCycles, task;
        foo = {
          bar: (function() {})
        };
        spyOn(foo, 'bar').and.callThrough();
        runCycles = 3;
        task = new CrunchTask(function(init, body, fin) {
          var count;
          count = runCycles;
          body(function(resolve, reject, notify) {
            notify('const', count--);
            if (!count) {
              resolve();
            }
          });
        });
        task.progress(foo.bar);
        expect(foo.bar.calls.any()).toEqual(false);
        task.run();
        task.always(function() {
          expect(foo.bar.calls.any()).toEqual(true);
          expect(foo.bar.calls.count()).toEqual(runCycles);
          expect(foo.bar.calls.argsFor(0)).toEqual(['const', runCycles]);
          expect(foo.bar.calls.argsFor(runCycles - 1)).toEqual(['const', 1]);
          done();
        });
      }));
      it('uses `abort` method called on `run` result to abort execution of a run-instance', function(done) {
        var foo, memo, result1, result2, safetyMargin, task, timeoutAmount;
        memo = {};
        foo = {
          bar: (function(id) {
            return memo[id] = (memo[id] || 0) + 1;
          })
        };
        spyOn(foo, 'bar').and.callThrough();
        timeoutAmount = 100;
        safetyMargin = Math.floor(timeoutAmount / 2);
        task = new CrunchTask(function(init, body, fin) {
          var id;
          id = null;
          init(function(_id) {
            return id = _id;
          });
          return body(function() {
            return foo.bar(id);
          }, 0, timeoutAmount);
        });
        task.always(function() {
          return expect(foo.bar.calls.any()).toEqual(true);
        });
        expect(foo.bar.calls.any()).toEqual(false);
        result1 = task.run(1);
        result2 = task.run(2);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(2);
          expect(memo[1]).toEqual(1);
          expect(memo[2]).toEqual(1);
          return result1.abort();
        }, timeoutAmount + safetyMargin);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(3);
          expect(memo[1]).toEqual(1);
          expect(memo[2]).toEqual(2);
          return result1.resume();
        }, 2 * timeoutAmount + safetyMargin);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(4);
          expect(memo[1]).toEqual(1);
          expect(memo[2]).toEqual(3);
          return task.abort();
        }, 3 * timeoutAmount + safetyMargin);
        setTimeout(function() {
          return done();
        }, 4 * timeoutAmount + safetyMargin);
      });
      it('uses `abort` method called on task to abort execution of all run-instances', function(done) {
        var moo, result1, result2, task;
        moo = {
          id: 1,
          bar: function() {}
        };
        spyOn(moo, 'bar').and.callThrough();
        task = new CrunchTask(function(init, body, fin) {
          return body(moo.bar);
        });
        expect(moo.bar.calls.any()).toEqual(false);
        task.always(function() {
          return expect(moo.bar.calls.any()).toEqual(false);
        });
        result1 = task.run();
        result2 = task.run();
        task.abort();
        window.setTimeout(done, 100);
      });
      it('uses `pause`/`resume` method pair called on `run` result to pause/resume the execution of a single thread', function(done) {
        var foo, memo, result1, result2, safetyMargin, task, timeoutAmount;
        memo = {};
        foo = {
          bar: (function(id) {
            return memo[id] = (memo[id] || 0) + 1;
          })
        };
        spyOn(foo, 'bar').and.callThrough();
        timeoutAmount = 100;
        safetyMargin = Math.floor(timeoutAmount / 2);
        task = new CrunchTask(function(init, body, fin) {
          var id;
          id = null;
          init(function(_id) {
            return id = _id;
          });
          return body(function() {
            return foo.bar(id);
          }, 0, timeoutAmount);
        });
        task.always(function() {
          return expect(foo.bar.calls.any()).toEqual(true);
        });
        expect(foo.bar.calls.any()).toEqual(false);
        result1 = task.run(1);
        result2 = task.run(2);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(2);
          expect(memo[1]).toEqual(1);
          expect(memo[2]).toEqual(1);
          return result1.pause();
        }, timeoutAmount + safetyMargin);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(3);
          expect(memo[1]).toEqual(1);
          expect(memo[2]).toEqual(2);
          return result1.resume();
        }, 2 * timeoutAmount + safetyMargin);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(5);
          expect(memo[1]).toEqual(2);
          expect(memo[2]).toEqual(3);
          return task.abort();
        }, 3 * timeoutAmount + safetyMargin);
        setTimeout(function() {
          return done();
        }, 4 * timeoutAmount + safetyMargin);
      });
      it('uses `pause`/`resume` method pair called on task to pause/resume the execution of  all run-instances', function(done) {
        var foo, result1, result2, safetyMargin, task, timeoutAmount;
        foo = {
          bar: (function() {})
        };
        spyOn(foo, 'bar').and.callThrough();
        timeoutAmount = 100;
        safetyMargin = Math.floor(timeoutAmount / 2);
        task = new CrunchTask(function(init, body, fin) {
          return body(foo.bar, 0, timeoutAmount);
        });
        expect(foo.bar.calls.any()).toEqual(false);
        task.always(function() {
          return expect(foo.bar.calls.any()).toEqual(true);
        });
        result1 = task.run();
        result2 = task.run();
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(2 * 1);
          return task.pause();
        }, timeoutAmount + safetyMargin);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(2 * 1);
          return task.resume();
        }, 2 * timeoutAmount + safetyMargin);
        setTimeout(function() {
          expect(foo.bar.calls.count()).toEqual(2 * 2);
          return task.abort();
        }, 3 * timeoutAmount + safetyMargin);
        setTimeout(function() {
          return done();
        }, 4 * timeoutAmount + safetyMargin);
      });
      it('uses `onIdle()` method to signal  all instances are finished and `isIdle()` method to check', function(done) {
        var task;
        task = new CrunchTask(function(init, body, fin) {
          body(function(resolve) {
            debugger;
            return resolve();
          });
        });
        task.onIdle(function() {
          expect(task.isIdle()).toBe(true);
          return done();
        });
        expect(task.isIdle()).toBe(true);
        task.run();
        task.run();
        expect(task.isIdle()).toBe(false);
      });
    });
    describe('Examples in the readme.md file', function() {
      var collatzTask;
      collatzTask = null;
      beforeEach(function() {
        collatzTask = new CrunchTask(function(init, body, fin) {
          var n, nInit, threshold, totalStoppingTime;
          nInit = n = threshold = null;
          totalStoppingTime = 0;
          init(function(_n, _threshold) {
            nInit = n = _n;
            threshold = _threshold;
          });
          body(function(resolve, reject) {
            if (n === 1) {
              return resolve(nInit, totalStoppingTime);
            }
            if (n > threshold) {
              return reject(nInit, threshold, n);
            }
            if (n % 2) {
              n = 3 * n + 1;
            } else {
              n = n / 2;
            }
            totalStoppingTime++;
          }, 100);
          fin(function(status) {
            if (status === false) {
              console.log('Collatz conjecture breaking candidate:', nInit);
            }
          });
        });
      });
      it('implements a Collatz conjecture, aka 3n + 1 problem, algorithm', function(ddone) {
        var runTask1;
        collatzTask.onIdle(ddone);
        runTask1 = collatzTask.run(1);
        expect(runTask1).toBeDefined();
        expect(runTask1.done).toBeDefined();
        expect(type(runTask1.done)).toEqual('function');
        runTask1.done(function(arr) {
          var count, n;
          n = arr[0], count = arr[1];
          expect(n).toEqual(1);
          expect(count).toEqual(0);
        });
        collatzTask.run(6).done(function(arr) {
          var count, n;
          n = arr[0], count = arr[1];
          expect(n).toEqual(6);
          expect(count).toEqual(8);
        });
        collatzTask.run(63728127).done(function(arr) {
          var count, n;
          n = arr[0], count = arr[1];
          expect(n).toEqual(63728127);
          expect(count).toEqual(949);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=crunchtaskSpec.js.map
